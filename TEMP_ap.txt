    if most_recent_only:
        from data.db_utils import get_most_recent_date
        recent = get_most_recent_date(conn, ticker)
        return [recent] if recent else []
    base = "SELECT DISTINCT asof_date FROM options_quotes"
    if ticker:
        df = pd.read_sql_query(f"{base} WHERE ticker = ? ORDER BY 1", conn, params=[ticker])
    else:
        df = pd.read_sql_query(f"{base} ORDER BY 1", conn)
    return df["asof_date"].tolist()

def get_most_recent_date_global() -> Optional[str]:
    """Most recent asof_date across all tickers."""
    conn = _get_ro_conn()
    from data.db_utils import get_most_recent_date
    return get_most_recent_date(conn)

def invalidate_cache() -> None:
    """Clear all in-memory caches and reset shared connection."""
    get_surface_grids_cached.cache_clear()
    get_atm_pillars_cached.cache_clear()
    available_tickers.cache_clear()
    available_dates.cache_clear()
    global _RO_CONN
    if _RO_CONN is not None:
        try:
            _RO_CONN.close()
        except Exception:
            pass
        _RO_CONN = None

# -----------------------------------------------------------------------------
# Smile helpers (GUI plotting)
# -----------------------------------------------------------------------------
def get_smile_slice(
    ticker: str,
    asof_date: Optional[str] = None,
    T_target_years: float | None = None,
    call_put: Optional[str] = None,  # 'C' or 'P' or None for both
    max_expiries: Optional[int] = None,  # Limit number of expiries
) -> pd.DataFrame:
    """
    Return a slice of quotes for plotting a smile (one date, one ticker).
    - If asof_date is None: use the most recent trading day for that ticker.
    - Accepts either date-only ('YYYY-MM-DD') or full timestamp inputs.
    - Matches rows by calendar day regardless of how asof_date is stored in DB.
    - If T_target_years is provided, keep only the nearest expiry for that T.
    """
    conn = get_conn()
    try:
        ticker = (ticker or "").upper()

        # Resolve the calendar day we should pull
        if not asof_date:
            from data.db_utils import get_most_recent_date
            asof_date = get_most_recent_date(conn, ticker)
            if not asof_date:
                return pd.DataFrame()

        asof_ts = pd.to_datetime(asof_date)
        day_str = asof_ts.strftime("%Y-%m-%d")

        # Robust day match: works whether DB stores TEXT dates with/without time
        q = """
            SELECT asof_date, ticker, expiry, call_put, strike AS K, spot AS S, ttm_years AS T,
                   moneyness, iv AS sigma, delta, is_atm
            FROM options_quotes
            WHERE ticker = ?
              AND substr(asof_date, 1, 10) = ?
        """
        df = pd.read_sql_query(q, conn, params=[ticker, day_str])

        if df.empty:
            return df

        # Optional call/put filter
        if call_put in ("C", "P"):
            df = df[df["call_put"] == call_put]
            if df.empty:
                return df

        # Optionally limit number of expiries (smallest T first)
        if max_expiries is not None and max_expiries > 0 and not df.empty:
            # group by expiry and keep the earliest (smallest T) expiries
            unique_exp = (
                df.groupby("expiry", as_index=True)["T"]
                  .first()
                  .sort_values(kind="stable")
            )
            keep = unique_exp.head(max_expiries).index.tolist()
            df = df[df["expiry"].isin(keep)]
            if df.empty:
                return df

        # If a target T is specified, keep only the nearest expiry
        if T_target_years is not None and not df.empty:
            # Find rows belonging to the expiry whose T is closest to target
            abs_diff = (df["T"].astype(float) - float(T_target_years)).abs()
            nearest_mask = abs_diff.groupby(df["expiry"]).transform("min") == abs_diff
            df = df[nearest_mask]
            if df["expiry"].nunique() > 1:
                # If multiple expiries tie, keep the one with the most rows
                top = df.groupby("expiry").size().sort_values(ascending=False).index[0]
                df = df[df["expiry"] == top]

        return df.sort_values(["call_put", "T", "moneyness", "K"], kind="stable").reset_index(drop=True)

    finally:
        try:
            conn.close()
        except Exception:
            pass



def prepare_smile_data(
    target: str,
    asof: str,
    T_days: float,
    model: str = "svi",
